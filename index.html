<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BracketRanker</title>
<style>
:root{--bg:#0b1020;--card:#121a33;--ink:#e7ecff;--muted:#95a0c6;--accent:#7dd3fc;--right:#34d399;--focus:#fbbf24}
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,#0b1020,#0a0f24 60%);color:var(--ink);font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
.wrap{max-width:1100px;margin:0 auto;padding:18px;display:grid;gap:18px}
.card{background:var(--card);border:1px solid #1d274a;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:16px}
input,textarea{width:100%;padding:12px 14px;border-radius:10px;border:1px solid #2a3a6a;background:#0a1430;color:var(--ink)}
button{padding:12px 14px;border-radius:10px;border:1px solid #2a3a6a;background:#0e1a3d;color:var(--ink);cursor:pointer}
button:hover{filter:brightness(1.08)}
.row{display:flex;gap:10px;align-items:center}
.grid{display:grid;gap:10px}
.two{grid-template-columns:1fr 1fr}
.pill{height:8px;background:#0a1430;border:1px solid #23325e;border-radius:999px;overflow:hidden}
.bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),#60a5fa);transition:width .3s}
.bracket{display:grid;grid-auto-flow:column;gap:12px;overflow:auto}
.round{display:grid;gap:8px;min-width:220px}
.match{background:#0b1533;border:1px solid #1d274a;border-radius:12px;padding:10px}
.seed{font:12px/1 ui-monospace,Menlo,Consolas,monospace;color:var(--muted)}
.entry{margin:6px 0;padding:8px;border-radius:8px;border:1px solid #2a3a6a;cursor:pointer}
.entry.active{outline:2px solid var(--focus)}
.entry.win{background:#0e1f3d}
.bracket {
  display: flex;
  justify-content: space-between;
  gap: 40px;
  overflow-x: auto;
  padding: 20px 0;
}

.round {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-around;
  gap: 40px;
  position: relative;
}

.match {
  background: #111a33;
  border: 1px solid #1d274a;
  border-radius: 10px;
  padding: 10px;
  width: 180px;
  text-align: center;
  position: relative;
}

.entry {
  margin: 6px 0;
  padding: 8px;
  border-radius: 8px;
  border: 1px solid #2a3a6a;
  cursor: pointer;
  transition: all 0.2s;
}

.entry:hover {
  background-color: #182550;
}

.entry.win {
  background-color: #1b295a;
  border-color: #3b82f6;
  box-shadow: 0 0 6px rgba(59,130,246,0.5);
}

.round::after {
  content: '';
  position: absolute;
  right: -20px;
  top: 0;
  bottom: 0;
  width: 2px;
  background: #25325c;
}
.round:last-child .match { box-shadow: 0 0 0 2px rgba(125,211,252,.25) inset; }
.round:last-child .entry.win { box-shadow: 0 0 10px rgba(125,211,252,.45); }
</style>
</head>
<body>
<div class="wrap">
<div class="card">
<h1>üèÜ BracketRanker</h1>
<div class="row">
<input id="codeInput" placeholder="Enter code (or leave empty to create)" />
<button id="loadBtn">Load</button>
<button id="browseBtn">Browse</button>
</div>
</div>


<div id="createCard" class="card" style="display:none">
<h2>Create a bracket</h2>
<label>Question</label>
<input id="question" placeholder="Which animal would win in a race?" />
<label>Entries (one per line)</label>
<textarea id="entries" rows="6" placeholder="Gorilla\nGiraffe\nElephant\nPenguin"></textarea>
<div class="row">
<button id="createBtn">Create</button>
<div id="createMsg" style="margin-left:8px;color:var(--muted)"></div>
</div>
</div>


<div id="playCard" class="card" style="display:none">
<h2 id="qText"></h2>
<div class="bracket" id="bracket"></div>
<div class="row" style="margin-top:10px">
<button id="submitBtn">Submit</button>
<div id="playMsg" style="margin-left:8px;color:var(--muted)"></div>
</div>
</div>


<div id="statsCard" class="card" style="display:none">
<h2>üìä Aggregate stats</h2>
<div id="stats"></div>
</div>


<div id="browseCard" class="card" style="display:none">
<h2>üîé Browse recent</h2>
<ul id="recent" style="list-style:none;padding:0;margin:0"></ul>
</div>
</div>


<script>
const APP_URL = 'https://script.google.com/macros/s/AKfycbwbrozFCFyWAgkKqxhKUyBc42HsNSh_0JdDPB0NvH5wlcnZY35KEMPdyeHWNgnrOhi8/exec';


// === helpers: no custom headers ‚Üí no preflight, plain body ===
async function apiGet(params){
const url = APP_URL + '?' + new URLSearchParams(params).toString();
const r = await fetch(url);
return r.json();
}
async function apiPost(payload){
const r = await fetch(APP_URL, { method:'POST', body: JSON.stringify(payload) });
try { return await r.json(); } catch { return {ok:true}; }
}


// deterministic shuffle by seed
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296}}
function strHash(s){let h=2166136261; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0;}
function seededShuffle(arr, seed){const r=mulberry32(seed); const a=arr.slice(); for(let i=a.length-1;i>0;i--){const j=Math.floor(r()* (i+1)); [a[i],a[j]]=[a[j],a[i]];} return a;}


// bracket build (single-elim, pad with byes)
function buildBracket(entries, seedStr){
const seed = strHash(seedStr);
const shuffled = seededShuffle(entries, seed);
// power-of-two pad
let n=1; while(n<shuffled.length) n<<=1;

// === BEGIN random bye distribution (no bye-vs-bye in Round 1) ===
const byeCount = n - shuffled.length;

// Edge case: if no byes, just fill straight across
if (byeCount === 0) {
  const round0 = Array.from({length:n}, (_,i) => ({
    entry: shuffled[i] ?? null,
    win: null
  }));
  // (existing, do not delete)
  const rounds = [round0];
  return rounds; // short-circuit
}

// We‚Äôll choose distinct first-round *pairs* to host byes,
// then pick a random side within each chosen pair.

// number of first-round pairs
const pairCount = n / 2;

// Build [0..pairCount-1], shuffle with seed
const pairIdxs = Array.from({length: pairCount}, (_,i)=>i);
const shuffledPairs = seededShuffle(pairIdxs, seed ^ 0x9e3779b9);

// Select the first `byeCount` pairs (guarantees ‚â§ 1 bye per pair)
const chosenPairs = new Set(shuffledPairs.slice(0, byeCount));

// Decide a side (top=0 or bottom=1) per chosen pair, using seeded RNG
const rng = mulberry32(seed ^ 0x85ebca6b);
const byeSlots = new Set();
chosenPairs.forEach(p => {
  const side = (rng() < 0.5 ? 0 : 1);
  const slotIndex = p * 2 + side; // map pair‚Üíslot
  byeSlots.add(slotIndex);
});

// Fill slots: put null in bye slots, and stream entries into the rest
const round0 = Array.from({length:n}, (_,i) => byeSlots.has(i) ? null : 'FILL');
const entriesIter = shuffled[Symbol.iterator]();
for (let i = 0; i < n; i++) {
  if (round0[i] === 'FILL') round0[i] = entriesIter.next().value ?? null;
}

// Wrap into node objects
for (let i = 0; i < n; i++) round0[i] = { entry: round0[i], win: null };
// === END random bye distribution (no bye-vs-bye in Round 1) ===


const rounds = [round0];
while(rounds[rounds.length-1].length>1){
const prev = rounds[rounds.length-1];
const next = [];
for(let i=0;i<prev.length;i+=2){ next.push({left:prev[i], right:prev[i+1], win:null}); }
rounds.push(next);
}
return rounds; // rounds[0] leaves, rounds[last] root array of size 1
}


function renderBracket(rootEl, rounds){
rootEl.innerHTML='';
// compute leaf matches from leaves up
const cols=[];
// Convert leaf nodes into pair matches
const leaves = rounds[0];
const r1=[]; for(let i=0;i<leaves.length;i+=2){ r1.push({a:leaves[i], b:leaves[i+1], pick:null}); }
cols.push(r1);
// subsequent rounds
for(let k=1;k<rounds.length;k++){
const prev = cols[k-1];
const cur = [];
for(let i=0;i<prev.length;i+=2){ cur.push({a:prev[i], b:prev[i+1], pick:null}); }
cols.push(cur);
}


function isEmpty(node){ return node === 'undefined'; }          // not decided/placed yet
function isBye(node){ return node && node.entry === null; }   // explicit bye
function hasEntry(node){ return node && node.entry != null; } // real name present

function label(node){
  // undefined ‚Üí blank (pending); null ‚Üí "‚Äî bye ‚Äî"; otherwise the entry string
  if (isEmpty(node)) return '';
  if (isBye(node)) return '‚Äî bye ‚Äî';
  if (!node || node.entry === undefined || node.entry === null) return '';
  return String(node.entry ?? '');
}

function placeWinner(roundIdx, matchIdx, winnerLabel){
  const nextCol = cols[roundIdx + 1];
  if (!nextCol) return;                          // no next round
  const nextMatch = nextCol[Math.floor(matchIdx / 2)];
  const side = (matchIdx % 2 === 0) ? 'a' : 'b'; // even ‚Üí a, odd ‚Üí b
  nextMatch[side] = { entry: winnerLabel, pick: null };
}

function pickAndAdvance(roundIdx, matchIdx, pickSide, m){
  m.pick = pickSide;
  const winnerLabel = label(pickSide === 'a' ? m.a : m.b);
  placeWinner(roundIdx, matchIdx, winnerLabel);
  update();
}

function update(){
rootEl.innerHTML='';
cols.forEach((matches, colIdx)=>{
const col = document.createElement('div'); col.className='round';
matches.forEach((m, i)=>{
const card = document.createElement('div'); card.className='match';
const e1 = document.createElement('div'); e1.className='entry'; e1.textContent = label(m.a);
const e2 = document.createElement('div'); e2.className='entry'; e2.textContent = label(m.b);


if (isBye(m.a) && hasEntry(m.b)) m.pick = 'b';
if (isBye(m.b) && hasEntry(m.a)) m.pick = 'a';

// If a pick exists (either by user click or valid bye auto-pick), advance winner
if (m.pick === 'a' || m.pick === 'b') {
  placeWinner(colIdx, i, label(m[m.pick]));
}

// apply selected styles
if (m.pick === 'a') e1.classList.add('win');
if (m.pick === 'b') e2.classList.add('win');

// click ‚Üí set pick and advance (even index ‚Üí nextMatch.a, odd index ‚Üí nextMatch.b)
e1.onclick = () => pickAndAdvance(colIdx, i, 'a', m);
e2.onclick = () => pickAndAdvance(colIdx, i, 'b', m);


const isFinal = (colIdx === cols.length - 1);
const heading = isFinal ? 'Champion' : `Round ${colIdx+1}`;
card.innerHTML = `<div class="seed">${heading}</div>`;

// === BEGIN champion render logic (single slot only if other side is bye/pending) ===
const aHas = hasEntry(m.a);      // real name
const bHas = hasEntry(m.b);
const aBye = isBye(m.a);
const bBye = isBye(m.b);

// final should be single-slot only if exactly one side is a real entry,
// and the other side is either a bye or still pending (undefined)
const singleFinal = isFinal && (
  (aHas && !bHas) || (bHas && !aHas) || (aHas && bBye) || (bHas && aBye)
);

if (singleFinal) {
  const winnerName =
    (m.pick === 'a' && aHas) ? label(m.a) :
    (m.pick === 'b' && bHas) ? label(m.b) :
    aHas ? label(m.a) : bHas ? label(m.b) : '';

  const single = document.createElement('div');
  single.className = 'entry win';
  single.textContent = winnerName || '';
  card.appendChild(single);
} else {
  // normal: show both sides so user can click a final
  card.appendChild(e1);
  card.appendChild(e2);
}
col.appendChild(card);
});
rootEl.appendChild(col);
});
}
update();


return {
getWinner(){
  const last = cols[cols.length - 1][0];
  if (!last) return null;

  if (last.pick === 'a') return label(last.a) || null;
  if (last.pick === 'b') return label(last.b) || null;

  const aHas = hasEntry(last.a);
  const bHas = hasEntry(last.b);
  const aBye = isBye(last.a);
  const bBye = isBye(last.b);

  // If exactly one real entry exists (other side pending or bye), that entry is champ
  if (aHas && (!bHas || bBye)) return label(last.a) || null;
  if (bHas && (!aHas || aBye)) return label(last.b) || null;

  return null; // both sides pending or both real but no pick yet
},
getRanking(){
// Round-1 entries (ground truth universe)
const round1Entries = cols[0].flatMap(m => {
    const a = (m?.a && m.a.entry != null) ? String(m.a.entry) : null;
    const b = (m?.b && m.b.entry != null) ? String(m.b.entry) : null;
    return [a, b].filter(x => x !== null);
});

// Collect losers per round (ignore pending and byes)
const losersByRound = cols.map(matches => {
    const losers = [];
    matches.forEach(m => {
    const aName = (m?.a && m.a.entry != null) ? String(m.a.entry) : null;
    const bName = (m?.b && m.b.entry != null) ? String(m.b.entry) : null;

    if (m.pick === 'a' && bName !== null) losers.push(bName);
    else if (m.pick === 'b' && aName !== null) losers.push(aName);
    });
    return losers;
});

const out = [];
const champ = this.getWinner();
if (champ) out.push(champ);

// Finalist (loser of the last round), if any
const finalLosers = losersByRound[losersByRound.length - 1] || [];
if (finalLosers[0]) out.push(finalLosers[0]);

// Earlier rounds losers: later-round losers rank higher
for (let r = losersByRound.length - 2; r >= 0; r--) {
    losersByRound[r].forEach(name => { if (!out.includes(name)) out.push(name); });
}

// Add any still-missing round-1 entries at the end (e.g., unplayed when user stops early)
round1Entries.forEach(name => { if (name && !out.includes(name)) out.push(name); });

return out;
},
// === END robust ranking ===

serialize(){ return cols; }
};
}


function scoreFromRanking(_ranking, cols){
  // === BEGIN round-based scoring (2^(roundReached-1)) ===
  // Lose in Round 1 ‚Üí 1, Round 2 ‚Üí 2, Round 3 ‚Üí 4, ‚Ä¶ Champion (final round R) ‚Üí 2^(R-1)
  const totalRounds = cols.length;
  const roundReached = new Map(); // name -> highest round reached (1-based)
  const namesFrom = m => {
    const a = (m && m.a && m.a.entry != null) ? String(m.a.entry) : null;
    const b = (m && m.b && m.b.entry != null) ? String(m.b.entry) : null;
    return {a,b};
  };

  // Start everyone we see in Round 1 at least at round 1
  (cols[0] || []).forEach(m => {
    const {a,b} = namesFrom(m);
    if (a) roundReached.set(a, Math.max(1, roundReached.get(a) || 0));
    if (b) roundReached.set(b, Math.max(1, roundReached.get(b) || 0));
  });

  // For each decided match:
  //  - loser reached this round (rIdx+1)
  //  - winner reached at least next round (rIdx+2)
  cols.forEach((round, rIdx) => {
    round.forEach(m => {
      const {a,b} = namesFrom(m);
      if (m.pick === 'a' || m.pick === 'b') {
        const winner = (m.pick === 'a') ? a : b;
        const loser  = (m.pick === 'a') ? b : a;

        if (loser)  roundReached.set(loser, Math.max(roundReached.get(loser)||1, rIdx + 1));
        if (winner) roundReached.set(winner, Math.max(roundReached.get(winner)||1, rIdx + 2));
      }
    });
  });

  // Final round may be single-slot (no pick): infer champion
  const last = (cols[totalRounds - 1] || [])[0];
  if (last) {
    const {a,b} = namesFrom(last);
    if (!last.pick) {
      const aHas = !!a, bHas = !!b;
      if (aHas && !bHas) roundReached.set(a, Math.max(roundReached.get(a)||1, totalRounds));
      if (bHas && !aHas) roundReached.set(b, Math.max(roundReached.get(b)||1, totalRounds));
    } else {
      // already handled above, but ensure champ reaches final round
      const champ = (last.pick === 'a') ? a : b;
      if (champ) roundReached.set(champ, Math.max(roundReached.get(champ)||1, totalRounds));
    }
  }

  // Convert to scores: 2^(roundReached-1)
  const scores = {};
  for (const [name, round] of roundReached.entries()) {
    scores[name] = Math.pow(2, Math.max(1, round) - 1);
  }
  return scores;
  // === END round-based scoring ===
}


// UI wiring
const codeInput = document.getElementById('codeInput');
const loadBtn = document.getElementById('loadBtn');
const browseBtn = document.getElementById('browseBtn');
const createCard = document.getElementById('createCard');
const playCard = document.getElementById('playCard');
const statsCard = document.getElementById('statsCard');
const qText = document.getElementById('qText');
const bracketEl = document.getElementById('bracket');
const submitBtn = document.getElementById('submitBtn');
const playMsg = document.getElementById('playMsg');
const createBtn = document.getElementById('createBtn');
const createMsg = document.getElementById('createMsg');
const entriesEl = document.getElementById('entries');
const questionEl = document.getElementById('question');
const browseCard = document.getElementById('browseCard');
const recentEl = document.getElementById('recent');


function show(id, vis){ document.getElementById(id).style.display = vis ? 'block' : 'none'; }


async function loadCode(code){
const res = await apiGet({action:'fetch_set', code});
if (!res.ok) { playMsg.textContent='Code not found.'; return; }
show('createCard', false);
show('playCard', true);
show('statsCard', true);
qText.textContent = res.question || 'Untitled bracket';


const rounds = buildBracket(res.entries, code);
const ui = renderBracket(bracketEl, rounds);


submitBtn.onclick = async () => {
const ranking = ui.getRanking();
if (!ranking[0]) { playMsg.textContent='Pick winners first!'; return; }

// use the rendered matches grid for scoring
const bracketCols = ui.serialize();
const scores = scoreFromRanking(ranking, bracketCols);

const payload = { action:'submit_picks', code, bracket: bracketCols, ranking, scores };
const out = await apiPost(payload);
if (out.ok) {
playMsg.textContent='Submitted!';
const agg = await apiGet({action:'stats', code});
renderStats(agg);
} else {
playMsg.textContent='Submit failed.';
}
};


const agg = await apiGet({action:'stats', code});
renderStats(agg);
}


function renderStats(agg){
const box = document.getElementById('stats');
if (!agg.ok){ box.textContent='No stats yet.'; return; }
const rows = agg.aggregate||[];
box.innerHTML = rows.map((r,i)=>`<div>${i+1}. <b>${r.entry}</b> ‚Äî total score ${r.totalScore} ${r.avgRank?`(avg rank ${r.avgRank.toFixed(2)})`:''} ¬∑ n=${r.samples}</div>`).join('');
}


loadBtn.onclick = async ()=>{
const code = (codeInput.value||'').trim().toUpperCase();
if (!code){ show('createCard', true); show('playCard', false); show('statsCard', false); return; }
await loadCode(code);
};


createBtn.onclick = async ()=>{
const question = (questionEl.value||'').trim();
const entries = (entriesEl.value||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
const out = await apiPost({action:'create_set', question, entries});
if (out.ok){
createMsg.innerHTML = `Code: <b>${out.code}</b> ‚Äî share this!`;
codeInput.value = out.code;
await loadCode(out.code);
} else {
createMsg.textContent = out.error || 'Failed to create.';
}
};


browseBtn.onclick = async ()=>{
const res = await apiGet({action:'browse'});
if (!res.ok){ return; }
browseCard.style.display='block';
recentEl.innerHTML = res.rows.map(r=>`<li style="margin:6px 0"><a href="#" data-code="${r.code}"><b>${r.question||r.code}</b></a> <span style="color:var(--muted)">(${r.entries.length} entries)</span></li>`).join('');
recentEl.querySelectorAll('a').forEach(a=>a.onclick=(e)=>{e.preventDefault(); codeInput.value=a.dataset.code; loadBtn.click();});
};


// Deep link ?code=FOO
const urlParams = new URLSearchParams(location.search);
if (urlParams.get('code')){ codeInput.value = urlParams.get('code').toUpperCase(); loadBtn.click(); }
</script>
</body>
</html>